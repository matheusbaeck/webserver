#include <vector>
#include <iostream>

class Worker {
	public:
		void doWork() const {
			std::cout << "Worker doing work.\n";
		}
};

class Server {
public:
		std::vector<Worker> workers;

		void addWorker(const Worker& worker) {
			workers.push_back(worker);
		}
};

class WorkerIterator {
	using ServerIterator = std::vector<Server>::const_iterator;
	using WorkerIteratorInternal = std::vector<Worker>::const_iterator;

	ServerIterator currentServer;
	ServerIterator endServer;
	WorkerIteratorInternal currentWorker;

	public:
		WorkerIterator(ServerIterator startServer, ServerIterator endServer)
			: currentServer(startServer), endServer(endServer) {
			if (currentServer != endServer) {
				currentWorker = currentServer->workers.begin();
				advanceToNextValid();
			}
		}

		bool operator!=(const WorkerIterator& other) const {
			return currentServer != other.currentServer || currentWorker != other.currentWorker;
		}

		const Worker& operator*() const {
			return *currentWorker;
		}

		WorkerIterator& operator++() {
			++currentWorker;
			advanceToNextValid();
			return *this;
		}

	private:
		void advanceToNextValid() {
			while (currentServer != endServer && currentWorker == currentServer->workers.end()) {
				++currentServer;
				if (currentServer != endServer) {
					currentWorker = currentServer->workers.begin();
				}
			}
		}
};

class ServerManager {
	public:
		std::vector<Server> servers;

		WorkerIterator begin() const {
			return WorkerIterator(servers.begin(), servers.end());
		}

		WorkerIterator end() const {
			return WorkerIterator(servers.end(), servers.end());
		}
};

int main() {
	Worker worker1, worker2, worker3;
	Server server1, server2;

	server1.addWorker(worker1);
	server1.addWorker(worker2);
	server2.addWorker(worker3);

	ServerManager manager;
	manager.servers.push_back(server1);
	manager.servers.push_back(server2);

	// Iterate over all workers using custom iterator
	for (const auto& worker : manager) {
		worker.doWork();
	}

	return 0;
}
